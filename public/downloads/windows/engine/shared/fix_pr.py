from __future__ import annotations

import datetime as _dt
import hashlib
from dataclasses import dataclass
from typing import Any, Dict, Optional, List, Tuple

from shared.envelope import extract_task_type
from shared.fix_suggester import suggest_fix
from shared.github_pr import create_autofix_pr, GitHubPRResult, get_file_text, upsert_file
from shared.patch_apply import split_unified_diff, apply_file_patch, PatchApplyError
from shared.runbooks import get_runbook
from shared.settings import settings


@dataclass
class FixPRResult:
    ok: bool
    pr: Optional[GitHubPRResult]
    suggestion: Optional[Dict[str, Any]]
    md_path: Optional[str] = None
    applied_files: Optional[List[str]] = None
    error: Optional[str] = None


def _slug(s: str) -> str:
    s = "".join([c if c.isalnum() or c in ("-", "_") else "-" for c in (s or "")])
    while "--" in s:
        s = s.replace("--", "-")
    return s.strip("-")[:80] or "item"


def _count_unified_diff_changes(unified_diff: str) -> Tuple[int, int]:
    """Return (files, changed_lines) rough estimates."""
    if not unified_diff.strip():
        return 0, 0
    files = 0
    lines = 0
    for line in unified_diff.splitlines():
        if line.startswith("diff --git "):
            files += 1
        if line.startswith("+++") or line.startswith("---") or line.startswith("@@"):
            continue
        if line.startswith("+") or line.startswith("-"):
            lines += 1
    return files, lines


def create_fix_pr_from_hold(
    msg: Dict[str, Any],
    failure_code: str,
    provider_override: Optional[str] = None,
    *,
    apply_patches: bool = False,
    allowlist: Optional[list[str]] = None,
    max_files: int = 5,
    max_lines: int = 400,
) -> FixPRResult:
    """Generate a GitHub PR containing a markdown fix suggestion.

    If apply_patches=True, it will attempt to apply *code_patch* unified diff directly to the repo
    (SAFE MODE: allowlist + file/line caps). This writes patched files into the PR branch.
    """

    sug = suggest_fix(msg, failure_code, provider_override=provider_override)
    if not sug.ok or not sug.data:
        return FixPRResult(False, None, None, None, error=sug.error or "suggest_fix failed")

    task_type = extract_task_type(msg)
    task_id = str(msg.get("task_id") or "unknown")
    rb = get_runbook(failure_code) or ""

    stamp = _dt.datetime.utcnow().strftime("%Y%m%d-%H%M%S")
    h = hashlib.sha1(f"{task_id}:{failure_code}:{stamp}".encode("utf-8")).hexdigest()[:8]

    branch_suffix = f"{stamp}-{_slug(task_type)}-{_slug(failure_code)}-{h}"
    base_dir = (getattr(settings, "github_autofix_dir", "") or ".nexus/autofix").strip("/")
    md_path = f"{base_dir}/{_slug(task_id)}-{_slug(failure_code)}-{h}.md"

    proposed = sug.data.get("proposed_changes", {}) if isinstance(sug.data, dict) else {}
    prompt_patch = str(proposed.get("prompt_patch", ""))
    schema_patch = str(proposed.get("schema_patch", ""))
    code_patch = str(proposed.get("code_patch", ""))

    md = f"""# NEXUS AutoFix Suggestion
- generated_at_utc: {stamp}
- task_id: `{task_id}`
- task_type: `{task_type}`
- failure_code: `{failure_code}`
- provider: `{sug.provider}`
- model: `{sug.model}`
- repaired: `{sug.repaired}`
- attempts: `{sug.attempts}`
- runbook: {rb}

## Issue summary
{sug.data.get("issue_summary", "")}

## Probable root cause
{sug.data.get("probable_root_cause", "")}

## Proposed changes

### prompt_patch
```diff
{prompt_patch}
```

### schema_patch
```diff
{schema_patch}
```

### code_patch
```diff
{code_patch}
```

## Risk
{sug.data.get("risk", "")}

## Verification

### tests
""" + "\n".join([f"- {t}" for t in (sug.data.get("verification", {}) or {}).get("tests", []) or ["(none)"]]) + "\n\n### dry_run_steps\n" + "\n".join(
        [f"- {t}" for t in (sug.data.get("verification", {}) or {}).get("dry_run_steps", []) or ["(none)"]]
    )

    pr_title = f"[AutoFix] {task_type}: {failure_code}"
    pr_body = f"""This PR was generated by NEXUS Supervisor.

- task_id: `{task_id}`
- failure_code: `{failure_code}`
- runbook: {rb}

It adds an autofix suggestion markdown file at `{md_path}`.

If patch-apply mode was enabled, selected file diffs are applied into this PR branch as well.
"""

    # Create PR with the markdown file.
    pr = create_autofix_pr(
        title=pr_title,
        body=pr_body,
        branch_suffix=branch_suffix,
        files={md_path: md},
    )
    if not pr.ok or not pr.pr_number:
        return FixPRResult(False, pr if pr.ok else None, sug.data, md_path, error=pr.error or "create_autofix_pr failed")

    applied_files: List[str] = []

    # Optional: apply code_patch unified diffs directly to repo branch (safe gating).
    if apply_patches and code_patch.strip():
        allow = set([p.strip() for p in (allowlist or []) if p.strip()])
        # Allowlist defaults to settings, if provided.
        if not allow:
            allow_cfg = (getattr(settings, "autofix_patch_allowlist", "") or "").strip()
            allow = set([p.strip() for p in allow_cfg.split(",") if p.strip()])

        file_count, line_count = _count_unified_diff_changes(code_patch)
        if file_count > max_files or line_count > max_lines:
            # Do not fail PR creation; just skip applying patches.
            return FixPRResult(True, pr, sug.data, md_path, applied_files=[], error=f"patch_limits_exceeded files={file_count} lines={line_count}")

        try:
            diffs = split_unified_diff(code_patch)
            for d in diffs:
                target = d.target_file
                if not target:
                    continue

                # Safe allowlist gate.
                if allow and not any(target.startswith(prefix) for prefix in allow):
                    continue

                before = get_file_text(pr.branch, target)
                if before is None:
                    before = ""

                after = apply_file_patch(before, d)
                upsert_file(
                    branch=pr.branch,
                    path=target,
                    content=after,
                    message=f"nexus autofix apply: {failure_code}",
                )
                applied_files.append(target)
        except PatchApplyError as e:
            return FixPRResult(True, pr, sug.data, md_path, applied_files=applied_files, error=f"patch_apply_error: {e}")
        except Exception as e:
            return FixPRResult(True, pr, sug.data, md_path, applied_files=applied_files, error=f"patch_apply_error: {e}")

    return FixPRResult(True, pr, sug.data, md_path, applied_files=applied_files)
